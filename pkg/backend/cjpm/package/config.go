package cjpmPackage

import (
	"bytes"
	"github.com/BurntSushi/toml"
	"os"
	"path"
	t "yi/pkg/types"
)

type Dependency struct {
	GitURL    string `toml:"git,omitempty"`
	GitBranch string `toml:"branch,omitempty"`
	Path      string `toml:"path,omitempty"`
	Version   string `toml:"version,omitempty"`
}

type PackageConfig struct {
	ComVer         string       `toml:"cjc-version"`
	CompilerOption string       `toml:"compiler-option"`
	Description    string       `toml:"description"`
	Name           string       `toml:"name"`
	Version        string       `toml:"version"`
	ScrPath        string       `toml:"src-dir"`
	TargetPath     string       `toml:"target-dir"`
	OutputType     t.OutputType `toml:"output-type"`
}

type CJPMDepend struct {
	GitURL    string `toml:"git"`
	GitBranch string `toml:"branch"`
	Path      string `toml:"path"`
	Version   string `toml:"version"`
}

type CJPMConfigV0 struct {
	Package PackageConfig `toml:"package"`
}

// Deprecated: Use t.ProjectConfig
func ReadCJPMConfig(p string) (CJPMConfigV0, error) {
	s, err := os.Stat(p)
	if err != nil {
		return CJPMConfigV0{}, err
	}
	if s.IsDir() {
		p = path.Join(p, "./cjpm.toml")
	}

	var config CJPMConfigV0
	_, err = toml.DecodeFile(p, &config)
	if err != nil {
		return CJPMConfigV0{}, err
	}
	return config, nil
}

func (c *CJPMConfigV0) WriteConfigToDir(p string) error {
	buf := bytes.NewBuffer([]byte{})

	err := toml.NewEncoder(buf).Encode(&c) // 将对象编码为TOML
	if err != nil {
		return err
	}

	s, err := os.Stat(p) // 如果传参为目录，则自动添加文件名
	if err == nil && s.IsDir() {
		p = path.Join(p, "./cjpm.toml")
	}

	err = os.WriteFile(p, buf.Bytes(), 0666) //写入文件
	if err != nil {
		return err
	}
	return nil
}

// WriteToConfig 将配置写人文件
// 当传入目录时，自动添加文件名
func (c *CJPMConfigV0) WriteToConfig(p string) error {
	return c.WriteConfigToDir(p)
}

func (c *CJPMConfigV0) GenerateFromPackageConfig(config t.PackageConfigV0) {
	c.Package.Name = config.Base.Name
	c.Package.Version = config.Base.Version
	c.Package.ComVer = config.Base.ComVer
	c.Package.Description = config.Base.Description
	c.Package.ScrPath = config.Base.ScrPath
	c.Package.TargetPath = config.Base.TargetPath
	c.Package.OutputType = config.Base.OutputType
	c.Package.CompilerOption = config.Base.CompilerOption
}
func (c *CJPMConfigV0) GenerateFromProjectConfig(config t.PackageConfigV0) {
	c.GenerateFromPackageConfig(config)
}

func NewCJPMConfigV0() *CJPMConfigV0 {
	return &CJPMConfigV0{Package: PackageConfig{OutputType: t.EXECUTABLE}}
}

type CJPMConfigV1 struct {
	Package PackageConfig         `toml:"package"`
	Depends map[string]Dependency `toml:"depends,omitempty"`
}

func NewCJPMConfigV1() *CJPMConfigV1 {
	c := new(CJPMConfigV1)
	c.Depends = make(map[string]Dependency)
	c.Package = PackageConfig{OutputType: t.EXECUTABLE}
	return c
}
func (c *CJPMConfigV1) GenerateFromPackageConfig(config t.PackageConfigV1) {
	c.Package.Name = config.Name
	c.Package.Version = config.Version
	c.Package.ComVer = config.ComVer
	c.Package.Description = config.Description
	c.Package.ScrPath = config.ScrPath
	c.Package.TargetPath = config.TargetPath
	c.Package.OutputType = config.OutputType
	c.Package.CompilerOption = config.CompilerOption
}

func (c *CJPMConfigV1) GenerateFromProjectConfig(config t.PackageConfigV1) {
	c.GenerateFromPackageConfig(config)
}

func (c *CJPMConfigV1) ToBytes() (*bytes.Buffer, error) {
	buf := bytes.NewBuffer([]byte{})

	buf.WriteString("# Generated by Yi\n")

	err := toml.NewEncoder(buf).Encode(&c) // 将对象编码为TOML
	if err != nil {
		return buf, err
	}

	return buf, nil
}

func (c *CJPMConfigV1) ToPackageConfig(p *t.PackageConfigV1) {
	if p == nil {
		p = t.NewPackageConfigV1()
	}

	p.Name = c.Package.Name
	p.Version = c.Package.Version
	p.ComVer = c.Package.ComVer
	p.Description = c.Package.Description
	p.ScrPath = c.Package.ScrPath
	p.TargetPath = c.Package.TargetPath
	p.OutputType = c.Package.OutputType
	p.CompilerOption = c.Package.CompilerOption
}

func (c *CJPMConfigV1) LoadFromDir(p string) error {
	s, err := os.Stat(p)
	if err != nil {
		return err
	}
	if s.IsDir() {
		p = path.Join(p, "./cjpm.toml")
	}

	_, err = toml.DecodeFile(p, &c)
	if err != nil {
		return err
	}
	return nil
}
